import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../app/store';
import {resIsError} from '../utils/helperRepo';
import {getEvents, createEvent, updateEvent, deleteEvent} from '../api/eventApi';

// thunks for each of our CRUD operations with error checking
export const getEventsAsync = createAsyncThunk(
  'events/getEvents',
  async (thunkAPI) => {
    const response = await getEvents();
    if (resIsError(response)) {
      return thunkAPI.rejectWithValue(response.toString());
    }
    return response;
  }
);
export const createEventAsync = createAsyncThunk(
  'events/createEvent',
  async (thunkAPI, event) => {
    const response = await createEvent(event);
    if (resIsError(response)) {
      return thunkAPI.rejectWithValue(response.toString());
    }
    return response;
  }
);
export const updateEventAsync = createAsyncThunk(
  'events/updateEvent',
  async (thunkAPI, event) => {
    const response = await updateEvent(event);
    if (resIsError(response)) {
      return thunkAPI.rejectWithValue(response.toString());
    }
    return response;
  }
);
export const deleteEventAsync = createAsyncThunk(
  'events/deleteEvent',
  async (eventID) => {
    const response = await deleteEvent(eventID);
    return response;
  }
);

export const eventSlice = createSlice({
  name: 'event',
  initialState : {
    showSidebar: false,
    errors: [],
    events: [],
  },
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    toggleSidebar: (state) => {
      state.showSidebar = !state.showSidebar;
    },
    clearErrors: (state) => {
      state.errors = [];
    },
    addErrorToQueue: (state, action) => {
      if (action.payload instanceof Error){
        state.errors.push(action.payload);
      }
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getEventsAsync.pending, (state, action) => {
        // TODO: Loading Animation
      })
      .addCase(getEventsAsync.fulfilled, (state, action) => {
        state.events = action.payload;
      })
      .addCase(getEventsAsync.failed, (state, action) => {
        // TODO: Error Toast
      })
      .addCase(createEventAsync.pending, (state, action) => {
        // add the event to state with a temporary ID so the UI updates immediately
        const newEvent = action.meta.arg.event;
        newEvent.id = action.meta.requestId;
        state.events.push(newEvent);
      })
      .addCase(createEventAsync.fulfilled, (state, action) => {
        // Update the ID in state by removing the temporary event and adding the real one.
        // I did it this way to force a re-render so that the event component in the UI has a valid ID to update/delete
        const index = state.events.findIndex((e) => e.id === action.meta.requestId);
        state.events = state.events.filter((state.events[index].id = action.payload.id));
        state.events.push(action.payload);
      })
      .addCase(createEventAsync.failed, (state, action) => {
        // oh no! the event wasn't created on the server so we need to remove it from state and notify the user
        const index = state.events.findIndex((e) => e.id === action.meta.requestId);
        state.events = state.events.filter((state.events[index].id = action.payload.id));
        // TODO: Error Toast
      })
      .addCase(updateEventAsync.pending, (state, action) => {
        // update the event in state immediately to update the UI
        const index = state.events.findIndex((e) => e.id === action.meta.requestId);
        state.events[index] = action.payload;
      })
      .addCase(updateEventAsync.failed, (state, action) => {
        // oh no! the event wasn't created on the server so we need to remove it from state and notify the user
        const index = state.events.findIndex((e) => e.id === action.meta.requestId);
        state.events = state.events.filter((state.events[index].id = action.payload.id));
        // TODO: Error Toast
      })
      .addCase(deleteEventAsync.pending, (state, action) => {
        // immediately remove the event from state to update the UI
        const index = state.events.findIndex((e) => e.id === action.meta.requestId);
        state.events = state.events.filter((state.events[index].id = action.payload.id));
      })
      .addCase(deleteEventAsync.failed, (state, action) => {
        // In the event that we try to delete an event on the server and fail, we need to restore it in state and let the user know it wasn't deleted
        // alternatively, we might keep it deleted and devise a mechanism to retry the server delete later.
        state.events.push(action.payload);
        // TODO: Error Toast
      })

  },
});

// Export actions
export const { toggleSidebar, clearErrors, addErrorToQueue } = eventSlice.actions;

// Export selectors for the Event Slice
export const selectEvents = (state) => state.events;
export const selectErrors = (state) => state.errors;
export const selectSidebarVisibility = (state) => state.showSidebar;

// Export reducer
export default eventSlice.reducer;
